<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Portfolio Terminal</title>
  <style>
    body {
      background-color: #1e1e1e;
      color: #f5f5f5;
      font-family: 'Courier New', Courier, monospace;
      margin: 0;
      padding: 20px;
    }

    .terminal {
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      background-color: #1e1e1e;
      min-height: 500px;
      overflow-y: auto;
    }

    .ascii-art {
      color: #f5f5f5;
      white-space: pre;
      margin-bottom: 1em;
    }

    .line { margin: 5px 0; white-space: pre-wrap; }
    .command-block { margin: 0; }
    .prompt-block { font-family: inherit; white-space: pre; line-height: 1.2; margin: 0; padding: 0; }

    .kali-prompt { color: #7aff00; }
    .username { color: #ff5555; }
    .hostname { color: #55aaff; }

    .terminal-input {
      background: none;
      border: none;
      color: #f5f5f5;
      outline: none;
      font-family: inherit;
      font-size: 1em;
      flex-grow: 1;
    }

    /* Colors */
    .command { color: #00ff00; } /* green for commands */
    .directory { color: #55aaff; } /* blue for directories */
    .text { color: #f5f5f5; } /* white for normal text */
    .error { color: #ff6666; } /* error red */

    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      height: 100vh;
      width: 100vw;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .overlay img {
      max-width: 90%;
      max-height: 90%;
      border: 4px solid #7aff00;
    }

    .overlay-close {
      position: fixed;
      top: 20px;
      right: 30px;
      font-size: 18px;
      color: #000;
      cursor: pointer;
      z-index: 1001;
      background-color: #7aff00;
      padding: 6px 10px;
      border-radius: 5px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="terminal" id="terminal">
    <div class="ascii-art" id="ascii-art">
__          __    _                                _
\ \        / /   | |                              | |
 \ \  /\  / /___ | |  ___   ___   _ __ ___    ___ | |
  \ \/  \/ // _ \| | / __| / _ \ | '_ ` _ \  / _ \| |
   \  /\  /|  __/| || (__ | (_) || | | | | ||  __||_|
    \/  \/  \___||_| \___| \___/ |_| |_| |_| \___|(_)
    v1.0.0
    </div>

    <div class="line" id="instructions">
      type <span class="command">help</span> to see a list of available commands.
    </div>

    <!-- Input area -->
    <div class="command-block" id="input-block">
      <pre class="prompt-block kali-prompt" id="prompt">
┌──(<span class="username">guestuser</span>㉿<span class="hostname">r00t</span>)-[~]
└─$ <input type="text" id="input" class="terminal-input" autocomplete="off" autofocus />
      </pre>
    </div>
  </div>

  <script>
    // -----------------------
    // Helper: safe text escaper
    // -----------------------
    function escapeHtml(text) {
      if (text === undefined || text === null) return '';
      return String(text).replace(/[&<>"'`]/g, (c) =>
        ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;', '`': '&#96;' }[c])
      );
    }

    // -----------------------
    // Helper: validate URL (allow only http/https)
    // -----------------------
    function isSafeUrl(urlStr) {
      try {
        const url = new URL(urlStr);
        return (url.protocol === 'http:' || url.protocol === 'https:');
      } catch (e) {
        return false;
      }
    }

    // -----------------------
    // DOM helpers (safe rendering)
    // -----------------------
    const terminal = document.getElementById('terminal');
    const inputBlock = document.getElementById('input-block');
    const promptEl = document.getElementById('prompt');

    function addLineNode(node, cls = 'text') {
      const wrapper = document.createElement('div');
      wrapper.className = 'line ' + cls;
      wrapper.appendChild(node);
      terminal.insertBefore(wrapper, inputBlock);
      terminal.scrollTop = terminal.scrollHeight;
    }

    function addTextLine(text, cls = 'text') {
      const node = document.createTextNode(text);
      addLineNode(node, cls);
    }

    function addHtmlLineSafe(htmlString, cls = 'text') {
      // Only use for trusted content generated by this script (not user input).
      const wrapper = document.createElement('div');
      wrapper.className = 'line ' + cls;
      wrapper.innerHTML = htmlString; // safe if htmlString is controlled by code
      terminal.insertBefore(wrapper, inputBlock);
      terminal.scrollTop = terminal.scrollHeight;
    }

    // Renders one command prompt as history (safe)
    function renderPromptHistory(commandText) {
      // create <pre> element but use textContent for the command to avoid HTML injection
      const pre = document.createElement('pre');
      pre.className = 'prompt-block kali-prompt';
      // build the prompt header as HTML (this is static/trusted), but insert user command as text node
      const header = document.createElement('span');
      header.innerHTML = `┌──(<span class="username">guestuser</span>㉿<span class="hostname">r00t</span>)-[${escapeHtml(cwd)}]
└─$ `;
      pre.appendChild(header);
      const cmdNode = document.createTextNode(commandText);
      pre.appendChild(cmdNode);
      const block = document.createElement('div');
      block.className = 'command-block';
      block.appendChild(pre);
      terminal.insertBefore(block, inputBlock);
    }

    // -----------------------
    // Virtual filesystem (safe)
    // -----------------------
    const fs = {
      "~": {
        type: "dir",
        contents: {
          "Certificates": {
            type: "dir",
            contents: {
              "CAPen.jpg": {
                type: "file",
                path: "https://candidate.speedexam.net/certificate.aspx?SSTATE=am4131EniU8ntjp4bO5mXbT4QdB5o91LpQ/Yi+17iUMoiYvdyLHdG0zeG0qEGvDKzqoWHXVdxHihM0uBjNs1lNf+aS4XYOkn8yDBz7nKzvc="
              },
              "CNPen.jpg": {
                type: "file",
                path: "https://candidate.speedexam.net/certificate.aspx?SSTATE=am4131EniU8ntjp4bO5mXblY3DeZ9H+GglTpJlSwv1LOhpqBQXy4c2xDbhjjyOcdewBBT3bTOx4PeFoUnwfKwm8du0GL//WpnEutcmi3Z/s="
              },
              "CRTA.jpg": {
                type: "file",
                path: "https://labs.cyberwarfare.live/credential/achievement/68a43a53f4c7625a2950ffdd"
              },
              "CWES.jpg": {
                type: "file",
                path: "https://www.credly.com/badges/1d68c171-351b-4c73-a5c4-86f467de8303/public_url"
              },
            }
          }
        }
      }
    };

    let cwd = "~";

    // Commands data (strings are safe controlled content)
    const commands = {
      whoami: "Hi, Marc Valbuena here! I’m passionate about penetration testing and risk management, with a focus on uncovering vulnerabilities and strengthening defenses. I enjoy sharing knowledge, simplifying risks, and helping others build stronger security strategies.",
      projects: "[Project 1] [Project 2] [Project 3]",
      repo: "GitHub: https://github.com/jackb1434",
      socials: "LinkedIn: https://www.linkedin.com/in/marc-valbuena/",
      skills: "HTML, CSS, JavaScript, Python, Linux, Networking"
    };

    // Help items (rendered programmatically, safer)
    const helpItems = [
      { cmd: 'whoami', desc: 'who am I?' },
      { cmd: 'projects', desc: 'view my projects' },
      { cmd: 'repo', desc: 'View project source' },
      { cmd: 'socials', desc: 'View my socials' },
      { cmd: 'skills', desc: 'View my current skills' },
      { cmd: 'ls', desc: 'list directory' },
      { cmd: 'cd [dir]', desc: 'change directory' },
      { cmd: 'pwd', desc: 'print working directory' },
      { cmd: 'cat [file]', desc: 'view file (image or URL)' },
      { cmd: 'clear', desc: 'clear the terminal' }
    ];

    // -----------------------
    // Utilities for FS access
    // -----------------------
    function getNode(path) {
      const parts = path.split("/").filter(p => p && p !== "~");
      let node = fs["~"];
      for (let p of parts) {
        if (node.contents && node.contents[p]) {
          node = node.contents[p];
        } else {
          return null;
        }
      }
      return node;
    }

    function resolvePath(dir) {
      if (!dir || dir === "~") return "~";
      if (dir === ".") return cwd;
      if (dir === "..") {
        if (cwd === "~") return "~";
        const arr = cwd.split("/");
        arr.pop();
        return arr.join("/") || "~";
      }
      if (dir.startsWith("~/")) {
        const node = getNode(dir);
        return (node && node.type === "dir") ? dir : null;
      }
      const newPath = (cwd === "~") ? `~/${dir}` : `${cwd}/${dir}`;
      const node = getNode(newPath);
      return (node && node.type === "dir") ? newPath : null;
    }

    // -----------------------
    // Overlay for images
    // -----------------------
    function showImageOverlay(imgPath) {
      // only allow safe URLs (http/https) or relative local paths
      if (!imgPath) return;
      // If it's remote, verify scheme
      if (/^https?:\/\//i.test(imgPath) && !isSafeUrl(imgPath)) {
        addTextLine('Refused to open unsafe URL', 'error');
        return;
      }

      const overlay = document.createElement('div');
      overlay.className = 'overlay';

      const closeBtn = document.createElement('div');
      closeBtn.className = 'overlay-close';
      closeBtn.innerText = 'Close';
      closeBtn.onclick = () => overlay.remove();

      const image = document.createElement('img');
      image.src = imgPath;
      image.alt = "certificate";

      overlay.appendChild(closeBtn);
      overlay.appendChild(image);

      // close by clicking background
      overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };

      document.body.appendChild(overlay);
    }

    // -----------------------
    // Prompt / input handling
    // -----------------------
    function updatePrompt() {
      // Rebuild prompt (safe: escape cwd in displayed prompt)
      promptEl.innerHTML =
`┌──(<span class="username">guestuser</span>㉿<span class="hostname">r00t</span>)-[${escapeHtml(cwd)}]
└─$ <input type="text" id="input" class="terminal-input" autocomplete="off" autofocus />`;
      const newInput = document.getElementById("input");
      if (newInput) {
        newInput.focus();
        bindInput(newInput);
      }
    }

    // bind key events to the live input (re-bind after prompt recreation)
    function bindInput(inp) {
      inp.addEventListener('keydown', function (e) {
        if (e.key === 'Enter') {
          const raw = inp.value || "";
          const value = raw.trim();
          if (value === '') return;

          // render history prompt safely
          renderPromptHistory(value);

          handleCommand(value);

          // ensure the history prompt and output are above input
          terminal.appendChild(inputBlock);
          updatePrompt();
          inp.value = '';
        }
      });
    }

    // initial binding
    (function init() {
      const initialInput = document.getElementById('input');
      if (initialInput) bindInput(initialInput);
    })();

    // -----------------------
    // Command dispatcher (safe)
    // -----------------------
    function handleCommand(rawValue) {
      // split (do not evaluate any HTML here)
      const parts = rawValue.split(/\s+/);
      const cmd = parts[0];
      const arg1 = parts[1] || "";

      // handle commands
      if (cmd === 'clear') {
        // remove all lines except prompt block and ascii-art/instructions
        document.querySelectorAll('.command-block, .line').forEach(el => {
          // keep ascii-art and instructions lines (we'll keep ascii-art id)
          if (el.id === 'ascii-art' || el.id === 'instructions') return;
          el.remove();
        });
        return;
      }

      if (cmd === 'help') {
        // Render help programmatically (safe)
        for (const item of helpItems) {
          const line = document.createElement('div');
          line.className = 'line';
          const cmdSpan = document.createElement('span');
          cmdSpan.className = 'command';
          cmdSpan.textContent = item.cmd;
          const desc = document.createTextNode(' - ' + item.desc);
          line.appendChild(cmdSpan);
          line.appendChild(desc);
          terminal.insertBefore(line, inputBlock);
        }
        return;
      }

      if (cmd === 'whoami' && commands.whoami) {
        addTextLine(commands.whoami, 'text');
        return;
      }

      if (cmd === 'projects' && commands.projects) {
        addTextLine(commands.projects, 'text');
        return;
      }

      if (cmd === 'repo' && commands.repo) {
        addTextLine(commands.repo, 'text');
        return;
      }

      if (cmd === 'socials' && commands.socials) {
        addTextLine(commands.socials, 'text');
        return;
      }

      if (cmd === 'skills' && commands.skills) {
        addTextLine(commands.skills, 'text');
        return;
      }

      if (cmd === 'ls') {
        const node = getNode(cwd);
        if (!node || node.type !== 'dir') {
          addTextLine('ls: cannot access directory', 'error');
          return;
        }
        // build safe listing: create spans for dirs, text nodes for files
        const line = document.createElement('div');
        line.className = 'line text';
        const items = Object.keys(node.contents).sort();
        items.forEach((name, i) => {
          const item = node.contents[name];
          if (item.type === 'dir') {
            const span = document.createElement('span');
            span.className = 'directory';
            span.textContent = name;
            line.appendChild(span);
          } else {
            // file: render as text
            const tn = document.createTextNode(name);
            line.appendChild(tn);
          }
          if (i < items.length - 1) {
            line.appendChild(document.createTextNode('   ')); // spacing
          }
        });
        terminal.insertBefore(line, inputBlock);
        return;
      }

      if (cmd === 'cd') {
        const newPath = resolvePath(arg1);
        if (newPath) {
          cwd = newPath;
        } else {
          addTextLine(`cd: no such file or directory: ${escapeHtml(arg1)}`, 'error');
        }
        return;
      }

      if (cmd === 'pwd') {
        addTextLine(cwd === "~" ? "~" : cwd, 'text');
        return;
      }

      if (cmd === 'cat') {
        const filename = arg1;
        const dirNode = getNode(cwd);
        if (dirNode && dirNode.contents[filename] && dirNode.contents[filename].type === "file") {
          const filePath = dirNode.contents[filename].path;
          // if remote, validate scheme
          if (/^https?:\/\//i.test(filePath)) {
            if (isSafeUrl(filePath)) {
              // open in new tab safely
              window.open(filePath, '_blank', 'noopener,noreferrer');
            } else {
              addTextLine('Refused to open unsafe URL', 'error');
            }
          } else {
            // local path (relative) - show overlay but still escape path
            showImageOverlay(filePath);
          }
        } else {
          addTextLine(`cat: ${escapeHtml(filename)}: No such file`, 'error');
        }
        return;
      }

      // check if it's one of the other pre-defined command outputs (safe)
      if (commands[cmd]) {
        addTextLine(commands[cmd], 'text');
        return;
      }

      // unknown command (render safe)
      addTextLine(`${escapeHtml(cmd)}: command not found`, 'error');
    }

  </script>
</body>
</html>
